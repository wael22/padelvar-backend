"""
Service pour le stockage et la distribution de vid√©os avec Bunny Stream CDN
G√®re l'upload des fichiers vid√©o vers Bunny Stream via l'API HTTP au lieu du FTP
"""

import os
import logging
import threading
import time
import json
from datetime import datetime
from typing import Optional, Dict, Any, Tuple
import requests
from pathlib import Path

# Configuration du logger
logger = logging.getLogger(__name__)

class BunnyStorageService:
    """Service de gestion du stockage vid√©o sur Bunny Stream CDN"""
    
    def __init__(self):
        """Initialise le service de stockage Bunny Stream"""
        self.upload_queue = []
        self.is_uploading = False
        self.upload_thread = None
        self.lock = threading.RLock()
        
        # Configuration depuis les variables d'environnement
        self.api_key = os.environ.get('BUNNY_API_KEY', 'dea74bd3-cb95-40f6-8b25e0cb6901-c108-4bf1')
        self.library_id = os.environ.get('BUNNY_LIBRARY_ID', '475694')
        self.cdn_hostname = os.environ.get('BUNNY_CDN_HOSTNAME', 'vz-f2c97d0e-5d4.b-cdn.net')
        
        # Configuration de l'API
        self.api_base_url = f"https://video.bunnycdn.com/library/{self.library_id}"
        
        # Configuration des headers API
        self.headers = {
            "AccessKey": self.api_key,
            "Content-Type": "application/json",
            "Accept": "application/json"
        }
        
        # Configuration de service
        self.config = {
            "api_key": self.api_key,
            "library_id": self.library_id,
            "storage_zone": self.cdn_hostname,
            "api_base_url": self.api_base_url
        }
    
    def is_configured(self) -> bool:
        """V√©rifie si le service est correctement configur√©"""
        return (
            bool(self.api_key) and
            bool(self.library_id) and
            bool(self.cdn_hostname)
        )
    
    def get_video_url(self, video_id: str) -> str:
        """
        G√©n√®re l'URL de visionnage pour une vid√©o stock√©e sur Bunny Stream CDN.
        
        Args:
            video_id: ID de la vid√©o sur Bunny Stream
            
        Returns:
            URL compl√®te de la vid√©o
        """
        # Format Bunny Stream CDN: https://<cdn_hostname>/<video_id>/play.mp4
        return f"https://{self.cdn_hostname}/{video_id}/play.mp4"
    
    def upload_file(self, local_path: str, title: Optional[str] = None, collection: Optional[str] = None) -> Tuple[bool, Optional[str], Optional[str]]:
        """
        Upload un fichier vers Bunny Stream via l'API HTTP.
        
        Args:
            local_path: Chemin local du fichier √† uploader
            title: Titre de la vid√©o
            collection: Collection √† laquelle ajouter la vid√©o
            
        Returns:
            Tuple (success, video_id, video_url)
        """
        try:
            if not os.path.exists(local_path):
                logger.error(f"Fichier non trouv√©: {local_path}")
                return False, None, None
            
            # Si le titre n'est pas sp√©cifi√©, utiliser le nom du fichier local
            if title is None:
                title = os.path.basename(local_path)
                
            # 1. Cr√©er la vid√©o sur Bunny Stream
            logger.info(f"Cr√©ation de la vid√©o sur Bunny Stream: {title}")
            create_data = {
                "title": title
            }
            
            # NE PAS AJOUTER collectionId car cela cause l'erreur "Collection does not exist"
            # Comment√© car cause des erreurs d'API
            # if collection:
            #     create_data["collectionId"] = collection
            
            response = requests.post(
                f"{self.api_base_url}/videos",
                headers=self.headers,
                json=create_data,
                timeout=30
            )
            
            if response.status_code not in [200, 201]:
                logger.error(f"Erreur cr√©ation vid√©o: {response.status_code} - {response.text}")
                return False, None, None
                
            video_data = response.json()
            video_id = video_data.get("guid")
            
            if not video_id:
                logger.error(f"Pas d'ID de vid√©o dans la r√©ponse: {video_data}")
                return False, None, None
                
            logger.info(f"Vid√©o cr√©√©e avec l'ID: {video_id}")
            
            # 2. Upload le fichier vid√©o
            upload_url = f"{self.api_base_url}/videos/{video_id}"
            
            try:
                with open(local_path, 'rb') as file:
                    logger.info(f"Upload de {local_path} vers Bunny Stream...")
                    upload_headers = {
                        "AccessKey": self.api_key,
                        "Content-Type": "application/octet-stream"
                    }
                    
                    upload_response = requests.put(
                        upload_url,
                        headers=upload_headers,
                        data=file,
                        timeout=300  # 5 minutes pour upload
                    )
                    
                    if upload_response.status_code not in [200, 201, 204]:
                        logger.error(f"Erreur upload: {upload_response.status_code} - {upload_response.text}")
                        return False, video_id, None
                        
                    logger.info(f"Upload r√©ussi pour vid√©o: {video_id}")
                    
            except Exception as upload_e:
                logger.error(f"Erreur fichier upload: {upload_e}")
                return False, video_id, None
            
            # 3. Attendre que la vid√©o soit trait√©e
            logger.info(f"Upload r√©ussi, vid√©o en cours de traitement: {video_id}")
            
            # G√©n√©rer l'URL de la vid√©o
            video_url = self.get_video_url(video_id)
            
            logger.info(f"Upload termin√© avec succ√®s! URL: {video_url}")
            return True, video_id, video_url
                
        except requests.exceptions.RequestException as e:
            logger.error(f"Erreur API lors de l'upload de {local_path}: {str(e)}")
            return False, None, None
        except Exception as e:
            logger.error(f"Erreur inattendue lors de l'upload de {local_path}: {str(e)}")
            return False, None, None
    
    def queue_upload(self, local_path: str, title: Optional[str] = None, collection: Optional[str] = None, metadata: Optional[Dict[str, Any]] = None) -> str:
        """
        Ajoute un fichier √† la queue d'upload.
        
        Args:
            local_path: Chemin local du fichier √† uploader
            title: Titre de la vid√©o (utilise le nom du fichier par d√©faut)
            collection: Collection √† laquelle ajouter la vid√©o
            metadata: M√©tadonn√©es associ√©es √† l'upload (id vid√©o, etc.)
            
        Returns:
            ID de l'upload dans la queue
        """
        if title is None:
            title = os.path.basename(local_path)
        
        upload_id = f"upload_{len(self.upload_queue) + 1}_{int(time.time())}"
        
        with self.lock:
            self.upload_queue.append({
                'id': upload_id,
                'local_path': local_path,
                'title': title,
                'collection': collection,
                'metadata': metadata or {},
                'status': 'pending',
                'retries': 0,
                'timestamp': datetime.now()
            })
            
            # D√©marrer le thread d'upload si pas d√©j√† en cours
            if not self.is_uploading:
                self.start_upload_thread()
        
        return upload_id
    
    def start_upload_thread(self):
        """D√©marre un thread d'upload pour traiter la queue en arri√®re-plan"""
        with self.lock:
            if self.is_uploading:
                return
            
            self.is_uploading = True
            self.upload_thread = threading.Thread(target=self._process_upload_queue)
            self.upload_thread.daemon = True
            self.upload_thread.start()
    
    def _process_upload_queue(self):
        """Traitement de la queue d'upload en arri√®re-plan"""
        try:
            # Importer les modules n√©cessaires ici pour √©viter les imports circulaires
            import time
            
            while True:
                # R√©cup√©rer le prochain fichier √† uploader
                upload_item = None
                with self.lock:
                    pending_uploads = [item for item in self.upload_queue if item['status'] == 'pending']
                    if not pending_uploads:
                        self.is_uploading = False
                        break
                    
                    upload_item = pending_uploads[0]
                    upload_item['status'] = 'uploading'
                
                # V√©rifier que le fichier existe
                if not os.path.exists(upload_item['local_path']):
                    logger.error(f"‚ùå Fichier non trouv√© pour l'upload: {upload_item['local_path']}")
                    with self.lock:
                        upload_item['status'] = 'failed'
                    time.sleep(1)
                    continue
                    
                # Uploader le fichier
                logger.info(f"üîÑ Upload du fichier {upload_item['local_path']} vers Bunny Stream en cours...")
                success, bunny_video_id, bunny_url = self.upload_file(
                    upload_item['local_path'], 
                    upload_item['title'],
                    upload_item.get('collection')
                )
                
                # Mettre √† jour le statut
                with self.lock:
                    if success and bunny_video_id and bunny_url:
                        upload_item['status'] = 'completed'
                        upload_item['bunny_video_id'] = bunny_video_id
                        upload_item['bunny_url'] = bunny_url
                        logger.info(f"‚úÖ Upload r√©ussi: {upload_item['title']} -> ID: {bunny_video_id}")
                        
                        # Mettre √† jour les m√©tadonn√©es si n√©cessaire (URL de la vid√©o, etc.)
                        if 'video_id' in upload_item['metadata']:
                            try:
                                # Importer dans le contexte local pour √©viter les imports circulaires
                                from src import create_app
                                from ..models.database import db
                                from ..models.user import Video
                                
                                app = create_app()
                                with app.app_context():
                                    video_id = upload_item['metadata']['video_id']
                                    video = Video.query.get(video_id)
                                    if video:
                                        # Mettre √† jour l'URL du fichier pour utiliser Bunny Stream
                                        video.file_url = bunny_url
                                        db.session.commit()
                                        logger.info(f"‚úÖ URL vid√©o {video_id} mise √† jour: {bunny_url}")
                            except Exception as e:
                                logger.error(f"‚ùå Erreur mise √† jour BDD: {str(e)}")
                    else:
                        upload_item['retries'] += 1
                        if upload_item['retries'] >= 3:
                            upload_item['status'] = 'failed'
                            logger.error(f"‚ùå Upload √©chou√© apr√®s 3 tentatives: {upload_item['local_path']}")
                        else:
                            upload_item['status'] = 'pending'
                            logger.warning(f"‚ö†Ô∏è Tentative {upload_item['retries']}/3 √©chou√©e pour {upload_item['local_path']}")
                
                # Pause entre les uploads pour √©viter de surcharger le serveur
                time.sleep(3)  # Augment√© pour Bunny Stream qui peut avoir des limites d'API
                
        except Exception as e:
            logger.error(f"‚ùå Erreur dans le thread d'upload: {str(e)}")
            with self.lock:
                self.is_uploading = False

    def upload_video_immediately(self, video_id, local_path, remote_filename=None):
        """
        Upload une vid√©o imm√©diatement via Bunny Stream API et met √† jour la base de donn√©es.
        Utile pour les migrations ou les uploads manuels.
        
        Args:
            video_id: ID de la vid√©o dans la base de donn√©es
            local_path: Chemin local du fichier
            remote_filename: Nom du fichier distant (utilis√© comme titre si sp√©cifi√©)
        
        Returns:
            Tuple (success, url) avec le statut et l'URL si succ√®s
        """
        try:
            # V√©rifier que le fichier existe
            if not os.path.exists(local_path):
                logger.error(f"‚ùå Fichier non trouv√©: {local_path}")
                return False, None
            
            # D√©terminer le titre de la vid√©o pour Bunny Stream
            title = remote_filename if remote_filename else f"Video {video_id}"
            
            # Upload vers Bunny Stream
            logger.info(f"üîÑ Upload imm√©diat de {local_path} vers Bunny Stream avec titre: {title}")
            success, bunny_video_id, bunny_url = self.upload_file(local_path, title)
            
            if success and bunny_video_id and bunny_url:
                logger.info(f"‚úÖ Upload imm√©diat r√©ussi: {bunny_url} (ID: {bunny_video_id})")
                
                try:
                    # Mettre √† jour la base de donn√©es
                    from src import create_app
                    from ..models.database import db
                    from ..models.user import Video
                    
                    app = create_app()
                    with app.app_context():
                        video = Video.query.get(video_id)
                        if video:
                            video.file_url = bunny_url
                            db.session.commit()
                            logger.info(f"‚úÖ URL vid√©o {video_id} mise √† jour")
                        else:
                            logger.warning(f"‚ö†Ô∏è Vid√©o {video_id} non trouv√©e en BDD")
                except Exception as e:
                    logger.error(f"‚ùå Erreur mise √† jour BDD: {str(e)}")
                
                return True, bunny_url
            else:
                logger.error(f"‚ùå √âchec de l'upload imm√©diat pour {local_path}")
                return False, None
                
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de l'upload imm√©diat: {str(e)}")
            return False, None


# Cr√©er une instance globale du service
bunny_storage_service = BunnyStorageService()
